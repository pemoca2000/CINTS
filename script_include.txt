var VASUtil = Class.create();
VASUtil.prototype = {
    initialize: function() {},

    // ============================================================
    // ACMS REST INTEGRATION METHODS
    // ============================================================
    getAccessCMSPayload: function() {

        var payload = {
            "id":"",
            "userId":"",
            "applicationId":"",
            "contextId":"",
            "userEUAId":"",
            "lastUpdated":"",
            "statuses": {
                "userHHSId": "",
                "securityReview": {
                    "status":"",
                    "reason": [
                        {
                            "field":"",
                            "reason": "",
                            "correction": "",
                            "sendto": ""
                        }
                    ],
                },
                "fingerprints": {
                    "current": {
                        "status": ""
                    }
                },
                "eApp": {
                    "current": {
                        "status": ""
                    }
                },
                "logicalAccess": {
                    "current": {
                        "status": "",
                        "denyReasons": [
                            {
                                "field":"",
                                "reason": "",
                                "correction": "",
                                "sendto": ""
                            }
                        ]
                    }
                }
            }
        };

        return payload;

    },

    // ============================================================
    // SM SOAP INTEGRATION METHODS
    // ============================================================

    /**
     * Main entry point called by the SM create integration business rule.
     * Triggered off of hhs_id on Applicnat record being populated by SCMS integration.  
	 * 
     * What it does:
     *  1) Finds a related case for this applicant
     *  2) Calls SM SOAP function SmsStdCreatePersParmCase
     *  3) Parses response "handles" (person/position/case)
     *  4) Writes handles back onto Applicant + Case records
     *
     * @param {GlideRecord} applicantGR - record from x_g_cfm_vas_applicant (BR current)
     * @returns {Object} result summary for debugging
     */

    createSmPersonPositionCase: function(applicantGR) {
        try {

            gs.info('PMC***** VASUtil.createSmPersonPositionCase started...');

            // 1) Find case related to this applicant
            var caseGR = this._getCaseForApplicant(applicantGR);
            if (!caseGR) {
                gs.warn('PMC***** [VASUtil.createSmPersonPositionCase] For applicant ' + applicantGR.getUniqueValue() + ' no related case was found or case already has SM handles.');
                return { ok: false, error: 'No related case found.' };
            } else {
				gs.info('PMC***** case ' + caseGR.getUniqueValue() + ' found for applicant');
			}

            // Optional: if case already has handles, skip (prevents duplicates)
            if (caseGR.sm_case_handle || caseGR.sm_position_handle) {
                gs.info('PMC***** [VASUtil] Case already has SM handles. Skipping. case=' + caseGR.getUniqueValue());
                return { ok: true, skipped: true, reason: 'Handles already present.' };
            }

            // 2) Build SOAP request object for the outbound SM SOAP message
            var soap = new sn_ws.SOAPMessageV2(
                'x_g_cfm_vas.VAS SM Outbound', // SOAP Message record name
                'SmsStdCreatePersParmCase'     // SOAP Message Function name
            );

            // 3) Apply HTTP Basic Auth Profile by name
            this._applyHttpBasicAuthProfile(soap);

            // NOTE:
            // If SM also requires SOAP header params AuthHeader.UserName/Password,
            // set them here from sys_properties (avoid hardcoding).
            // soap.setStringParameterNoEscape('AuthHeader.UserName', gs.getProperty('x_g_cfm_vas.sm.soap_user'));
            // soap.setStringParameterNoEscape('AuthHeader.Password', gs.getProperty('x_g_cfm_vas.sm.soap_pass'));

            // 4) Build payload map (SOAP param -> string value)
            var payload = this._buildSmsStdCreatePayload(caseGR, applicantGR);

            gs.info('PMC***** [VASUtil.createSmPersonPositionCase] payload = ' + JSON.stringify(payload, null, 2));
			

            /***************************
			 * ***********************************/

            // Apply all mapped parameters to SOAP message
            this._applyParams(soap, payload);

            // 5) Execute SOAP call
            var response = soap.execute();
            var status = response.getStatusCode();
            var body = response.getBody();

            gs.info('PMC***** [VASUtil.createSmPersonPositionCase] status code = ' + status);
            gs.info('PMC***** [VASUtil.createSmPersonPositionCase] response XML = \n' + body);

            if (status < 200 || status > 299) {
                this._logFailure(applicantGR, caseGR, status, body);
                return { ok: false, httpStatus: status, body: body };
            }

            // 6) Parse response handles (person/position/case)
            var handles = this._parseHandles(body);

            // Validate required handles exist
            if (!handles.personHandle || !handles.positionHandle || !handles.caseHandle) {
                gs.error('PMC***** [VASUtil] SOAP succeeded but missing one or more handles. applicant='
                    + applicantGR.getUniqueValue() + ', case=' + caseGR.getUniqueValue());
                gs.error('PMC***** [VASUtil] Response body: ' + body);
                return { ok: false, httpStatus: status, body: body, handles: handles };
            }

            // 7) Write handles back to SN records
            this._writeHandles(applicantGR, caseGR, handles);

            gs.info('PMC***** [VASUtil] SM create succeeded. applicant=' + applicantGR.getUniqueValue()
                + ' case=' + caseGR.getUniqueValue()
                + ' personHandle=' + handles.personHandle
                + ' positionHandle=' + handles.positionHandle
                + ' caseHandle=' + handles.caseHandle);

            return { ok: true, httpStatus: status, handles: handles };

			

        } catch (ex) {
            // ex may be an object or a string depending on where it came from
            var msg = (ex && ex.message) ? ex.message : (ex + '');
            gs.error('PMC***** [VASUtil] Exception in createSmPersonPositionCase: ' + msg);
            return { ok: false, error: msg };
        }
    },

    /**
     * Finds the related case record for an applicant.
     *
     * Current behavior:
     *  - Looks for x_g_cfm_vas_case where case.applicant == applicant.sys_id
     *  - Prefers cases that don't already have SM handles
     *  - Returns most recently created case (sys_created_on desc)
     */
    _getCaseForApplicant: function(applicantGR) {
        var c = new GlideRecord('x_g_cfm_vas_case');

        // Case has a reference field called "applicant" which we use to find the case
        // pointing to x_g_cfm_vas_applicant.
        c.addQuery('applicant', applicantGR.getUniqueValue());

        // Prefer cases without handles
        c.addNullQuery('sm_case_handle');
        c.addNullQuery('sm_position_handle');

        c.orderByDesc('sys_created_on');
        c.setLimit(1);
        c.query();

        if (c.next()) return c;
        return null;
    },

    /**
     * Applies HTTP Basic Auth using sys_auth_profile_basic with name:
     * "VAS SM Dev Basic Auth Creds"
     */
    _applyHttpBasicAuthProfile: function(soap) {
        var profileSysId = this._getBasicAuthProfileSysId('VAS SM Dev Basic Auth Creds');
        if (!profileSysId) {
            gs.warn('PMC***** [VASUtil] Basic auth profile not found: VAS SM Dev Basic Auth Creds');
            return;
        }
        // authType = 'basic' for sys_auth_profile_basic
        soap.setAuthenticationProfile('basic', profileSysId);
    },

    /**
     * Looks up sys_auth_profile_basic by name and returns sys_id
     */
    _getBasicAuthProfileSysId: function(profileName) {
        var p = new GlideRecord('sys_auth_profile_basic');
        p.addQuery('name', profileName);
        p.setLimit(1);
        p.query();
        if (p.next()) return p.getUniqueValue();
        return '';
    },

    /**
     * Builds the payload map for SmsStdCreatePersParmCase.
     *
     * This is the "mapping layer" where we handle:
     *  - SN field names not matching SOAP param names
     *  - Choice/value translations (tier_4 -> T4, etc.)
     *  - Defaults when fields are empty
     */
    _buildSmsStdCreatePayload: function(caseGR, applicantGR) {

        // Safely read a value from a GlideRecord field.
        // If field doesn't exist or value is empty, returns ''.
        function getVal(gr, fieldName) {
            if (!gr || !gr.isValidField(fieldName)) return '';
            return (gr.getValue(fieldName) || '').toString();
        }

        // Translates tiers from SN choice values to SM expected values
        // per your updated notes (tier_4 => T4, etc.)
        var tierMap = {
            'tier_1': 'T1',
            'tier_2': 'T2',
            'tier_3': 'T3',
            'tier_4': 'T4',
            'tier_5': 'T5'
        };
        function mapTier(v) {
            if (!v) return '';
            return tierMap[v] || v; // fall back to original if no match
        }

        // Convert boolean-ish values to Yes/No strings (SM examples used Yes)
        function yesNo(v) {
            if (v === true || v === 'true' || v === '1') return 'Yes';
            return 'No';
        }


        //below is for testing only until I get ssn decryption working
        var nineDigit = Math.floor(100000000 + Math.random() * 900000000); // 100000000â€“999999999
        var test_ssn = nineDigit + '';


        // Build the SOAP param map (key = SOAP param name, value = string)
        // Names based on your working example + updated field list.
        return {
            // ---------------------------
            // CaseParams
            // ---------------------------
            //'CaseParams.caseStatus': getVal(caseGR, 'case_status'),
			'CaseParams.caseStatus': 'OPEN',
            'CaseParams.dateApplicantSignature': getVal(caseGR, 'date_of_applicants_signature'),
            'CaseParams.investigationBasisRequested': mapTier(getVal(caseGR, 'investigation_basis_requested')),
            'CaseParams.datePaperworkReceived': getVal(caseGR, 'cor_approval_date'),

            // Defaults shown in your working example (adjust if you have fields)
            'CaseParams.casePriorityLevel': getVal(caseGR, 'case_priority_level') || 'None',
            'CaseParams.caseType': getVal(caseGR, 'case_type') || 'Suitability',

            // Example: using case badge_requested as pivRequested
            'CaseParams.pivRequested': yesNo(getVal(caseGR, 'badge_requested')),

            // Email of requester (using applicant agency_email as a sensible default)
            'CaseParams.requestingUserEmail': getVal(caseGR, 'cor_email'),

            // ---------------------------
            // PositionParams
            // ---------------------------
            //'PositionParams.positionSensitivity': getVal(caseGR, 'position_sensitivity'),
			'PositionParams.positionSensitivity': '1',  //hardcoded for now until mapping is resolved
            'PositionParams.positionTitle': getVal(caseGR, 'position_title'),
            'PositionParams.employeeType': getVal(caseGR, 'employee_type') || 'CONTRACTOR',
            'PositionParams.employeeStatus': getVal(applicantGR, 'employee_status') || 'active',
            'PositionParams.organization': getVal(caseGR, 'organization') || 'CMS',

            // ---------------------------
            // contractInfo (part of the position section in your example)
            // ---------------------------
            'contractInfo.contractorName': getVal(caseGR, 'contractor_company'),
            'contractInfo.activeStatus': 'Active',

            // Contract number/name (choose what's populated)
            'contractInfo.contractNumber': getVal(caseGR, 'contract_name') || getVal(caseGR, 'contract'),

            // Start/end dates can live on case or applicant in some designs; try case first
            'contractInfo.contractStartDate': getVal(caseGR, 'contract_start_date') || getVal(applicantGR, 'contract_start_date'),
            'contractInfo.contractEndDate': getVal(caseGR, 'contract_end_date') || getVal(applicantGR, 'contract_end_date'),

            // ---------------------------
            // PersonParams
            // ---------------------------
            'PersonParams.firstName': getVal(applicantGR, 'legal_first_name'),
            'PersonParams.middleName': getVal(applicantGR, 'middle_name'),
            'PersonParams.lastName': getVal(applicantGR, 'legal_last_name'),
            'PersonParams.email': getVal(applicantGR, 'personal_email'),

            'PersonParams.birthCity': getVal(applicantGR, 'birth_city'),
            'PersonParams.birthState': getVal(applicantGR, 'birth_state'),
            'PersonParams.birthCountry': getVal(applicantGR, 'birth_country'),
            'PersonParams.citizenshipCountry': getVal(applicantGR, 'citizenship_country'),

            // These may or may not exist in your table; getVal() prevents errors.
            'PersonParams.birthDate': getVal(applicantGR, 'date_of_birth'),
            //'PersonParams.ssn': getVal(applicantGR, 'ssn'),

            //below sets ssn to random 9 digit number temporarily until I get the decryption working
			'PersonParams.ssn': test_ssn,

            //'PersonParams.isSsnNotAvailable': getVal(applicantGR, 'is_ssn_not_available') || 'false'
			'PersonParams.isSsnNotAvailable': 'false'
        };
    },

    /**
     * Applies every payload key/value as a SOAP parameter.
     * Using setStringParameterNoEscape matches ServiceNow-generated SOAP code.
     */
    _applyParams: function(soapMsg, payloadObj) {
        for (var key in payloadObj) {
            if (payloadObj.hasOwnProperty(key)) {
                soapMsg.setStringParameterNoEscape(key, payloadObj[key]);
            }
        }
    },

    /**
     * Parses the 3 handles from the SOAP response XML.
     *
     * Uses XPath local-name() so namespaces do not break extraction.
     * Response fields:
     *  - PersonResponse/personHandle
     *  - PositionResponse/positionHandle
     *  - CaseResponse/caseHandle
     */
    _parseHandles: function(responseXml) {
        var out = { personHandle: '', positionHandle: '', caseHandle: '' };

        var xml = new XMLDocument2();
        xml.parseXML(responseXml);

        out.personHandle = (xml.getNodeText("//*[local-name()='PersonResponse']/*[local-name()='personHandle']") || '').trim();
        out.positionHandle = (xml.getNodeText("//*[local-name()='PositionResponse']/*[local-name()='positionHandle']") || '').trim();
        out.caseHandle = (xml.getNodeText("//*[local-name()='CaseResponse']/*[local-name()='caseHandle']") || '').trim();

        return out;
    },

    /**
     * Writes SM handles back into ServiceNow records:
     *  - Applicant.sm_person_handle
     *  - Case.sm_position_handle
     *  - Case.sm_case_handle
     *
     * setWorkflow(false) is used to reduce side effects (other BR/workflows).
     */
    _writeHandles: function(applicantGR, caseGR, handles) {
        // Update applicant
        applicantGR.setWorkflow(false);
        applicantGR.sm_person_handle = handles.personHandle;
        applicantGR.update();

        // Update case
        caseGR.setWorkflow(false);
        caseGR.sm_position_handle = handles.positionHandle;
        caseGR.sm_case_handle = handles.caseHandle;
        caseGR.update();
    },

    /**
     * Logs failures with enough context to debug quickly.
     */
    _logFailure: function(applicantGR, caseGR, status, body) {
        gs.error('PMC***** [VASUtil] SM create failed. HTTP ' + status
            + ' applicant=' + applicantGR.getUniqueValue()
            + ' case=' + caseGR.getUniqueValue());
        gs.error('PMC***** [VASUtil] Response: ' + body);
    },

    type: 'VASUtil'
};
